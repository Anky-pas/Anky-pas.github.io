<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一些Linux上常用的命令</title>
      <link href="/2021/02/13/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/02/13/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>打开或新建文件：touch 文件名<br/><br>编辑文件：vi 文件名 或 vim 文件名 (vi命令和vim命令在文件不存在时会创建文件)，按a或i进入编辑模式，按Esc进入命令模式<br/><br>当处于命令模式下时，输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:w 保存但不退出</span><br><span class="line">:wq 保存并退出</span><br><span class="line">:q 退出</span><br><span class="line">:e! 放弃所有修改</span><br></pre></td></tr></table></figure><p>移动文件：mv 文件名 要移动到的目录<br/><br>删除文件：rm 文件名<br/><br>远程上传文件：rz<br/><br>新建文件夹：mkdir 文件夹名<br/><br>删除文件夹：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -r 文件夹名  //需要一个个确认文件夹中的文件是否要删除</span><br><span class="line">rm -rf 文件夹名 //无需确认，直接删除整个文件夹</span><br></pre></td></tr></table></figure><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>查看正在运行中的进程：ps<br/><br>查看所有进程的详细信息：ps -ef<br/><br>杀死进程：kill 进程id<br/><br>实时动态查看系统运行情况：top<br/><br>不挂断运行某条命令语句（当账户退出或终端关闭时,程序仍然运行）：nohup 命令语句<br/><br>Linux下还有一个特殊的文件/dev/null，它就像一个无底洞，所有重定向到它的信息都会消失得无影无踪。这一点非常有用，当我们不需要回显程序的所有信息时，就可以将输出重定向到/dev/null。<br>由于使用nohup时，会自动将输出写入nohup.out文件中，如果文件很大的话，nohup.out就会不停的增大，这是我们不希望看到的，因此，可以利用/dev/null来解决这个问题。</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>不重启系统使配置文件、环境变量生效：source /etc/profile<br/><br>有时候经常需要修改系统配置文件，但系统上有项目正在运行，每次都重启系统，显然不合适</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最佳归并树</title>
      <link href="/2021/02/12/%E6%9C%80%E4%BD%B3%E5%BD%92%E5%B9%B6%E6%A0%91/"/>
      <url>/2021/02/12/%E6%9C%80%E4%BD%B3%E5%BD%92%E5%B9%B6%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近碰到一道题：已知三叉树T中6个叶结点的权分别是2，3，4，5，6，7，求T的带权路径长度的最小值（某年计算机研究生考试真题）。<br><br>看到最短带权路径长度，第一反应是哈夫曼树，但题目中说了是三叉树，而哈夫曼树是二叉树，因此直接套用哈夫曼树显然是是不行的，但可以借鉴哈夫曼树的思想。<br></p><h2 id="哈夫曼树的构建"><a href="#哈夫曼树的构建" class="headerlink" title="哈夫曼树的构建"></a>哈夫曼树的构建</h2><ol><li>将n个结点看作n棵仅含一个结点的二叉树，构成森林F</li><li>构造一个新结点，从F中选取根结点权值最小的两棵二叉树A、B作为新结点的左、右子树形成一颗新的二叉树C，并将树C根结点的权值设为左、右子树根结点权值之和</li><li>从F中删除A、B，并将C加入F</li><li>重复步骤2、3直至F中只剩下一颗树</li></ol><p>可以看到，构建哈夫曼树最重要的思想，就是尽可能让权值大的结点靠近根结点，即先合并权值小的结点。<br></p><h2 id="最佳归并树的构建"><a href="#最佳归并树的构建" class="headerlink" title="最佳归并树的构建"></a>最佳归并树的构建</h2><p>先上一个结论：对于含m个叶结点的k叉树，若(m - 1) % (k - 1) = 0，则不需要添加虚结点（规范的叫法是虚段），否则需要添加(k - 1) - (m - 1) % (k - 1)个虚结点。<br><br>所谓虚结点，就是权值比任何结点都小，但实际建树时不存在的结点。<br><br>于是k叉“哈夫曼树”的构建描述为：<br></p><ol><li>将m个结点看作m棵仅含一个结点的k叉树，构成森林F</li><li>构造一个新结点，从F中选取根结点权值最小的k棵k叉树（若有虚结点，则包含虚结点）作为新结点的子树形成一颗新的k叉树，并将根结点的权值设为所有子树根结点权值之和（求和时将虚结点的权值看作0）</li><li>从F中删除步骤2中选中的k棵k叉树，并将新的k叉树加入F</li><li>重复步骤2、3直至F中只剩下一颗K树</li></ol><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>在许多应用中，经常需要对大文件进行排序，因为文件过大，无法将整个文件数据读入内存，因此需要将待排序的数据存储在外存，排序时在把数据划分成一块块可以读入内存的数据块读入内存进行归并排序，再将排好序的数据块存储到外存，由于排序过程中需要多次进行内存和外存的交换，而内外存的交换相当耗时，因此需要合理组织待排数据块的归并顺序，使得内存与外存的交换总次数最少，这就需要使用最佳归并树。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> k叉树 </tag>
            
            <tag> 哈夫曼树 </tag>
            
            <tag> 最佳归并树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单请求和复杂请求</title>
      <link href="/2020/10/20/%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82%E5%92%8C%E5%A4%8D%E6%9D%82%E8%AF%B7%E6%B1%82/"/>
      <url>/2020/10/20/%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82%E5%92%8C%E5%A4%8D%E6%9D%82%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h2><p>同时满足以下两个条件的是简单请求：</p><ol><li>HTTP方法是head、get、post之一</li><li>HTTP头部信息不超出以下几种字段<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Accept</span><br><span class="line">Accept-Language</span><br><span class="line">Content-Language</span><br><span class="line">Last-Event-ID</span><br><span class="line">Content-Type </span><br></pre></td></tr></table></figure>且Content-Type仅能是下列之一<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">application/x-www-form-urlencoded</span><br><span class="line">multipart/form-data</span><br><span class="line">text/plain</span><br></pre></td></tr></table></figure><br/></li></ol><h2 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h2><p>不是简单请求的即为复杂请求<br/></p><h2 id="简单请求和复杂请求的区别"><a href="#简单请求和复杂请求的区别" class="headerlink" title="简单请求和复杂请求的区别"></a>简单请求和复杂请求的区别</h2><p>复杂请求在正式请求前会先发送一个预请求，预请求以options形式发送，在CORS（跨域资源共享）中，options头部会包含以下两个特有字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Request-Method – 该项内容是实际请求的类型，如get、post、put、delete等。</span><br><span class="line">Access-Control-Request-Headers – 该项是一个以逗号分隔的列表，当中是复杂请求所使用的头部。</span><br></pre></td></tr></table></figure><p>服务端需要对这两个字段进行回应，若服务端未进行回应，客户端将认为服务器不支持该跨域请求，于是不再发送正式请求。<br/><br>复杂请求的部分响应头及解释如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin（必含） – 允许跨域访问的源地址。</span><br><span class="line">Access-Control-Allow-Methods（必含） – 这是对预请求当中Access-Control-Request-Method的回复，这一回复将是一个以逗号分隔的列表。尽管客户端或许只请求某一方法，但服务端仍然可以返回所有允许的方法，以便客户端将其缓存。</span><br><span class="line">Access-Control-Allow-Headers（当预请求中包含Access-Control-Request-Headers时必须包含） – 这是对预请求当中Access-Control-Request-Headers的回复，和上面一样是以逗号分隔的列表，可以返回所有支持的头部。</span><br><span class="line">Access-Control-Allow-Credentials（可选） – 和简单请求当中作用相同。</span><br><span class="line">Access-Control-Max-Age（可选） – 以秒为单位的缓存时间。预请求的的发送并非免费午餐，允许时应当尽可能缓存。</span><br></pre></td></tr></table></figure><p>客户端收到响应后，根据Access-Control-Allow-Origin字段判断服务端是否允许自己跨域访问，根据Access-Control-Allow-Methods字段判断服务端是否允许自己以预请求中Access-Control-Request-Method字段中的请求类型访问，决定是否发送正式请求。<br/></p><h2 id="一些经验"><a href="#一些经验" class="headerlink" title="一些经验"></a>一些经验</h2><ol><li>options无法在Serve中被捕获到，因此不能在Serve中处理，需要在Serve之前的Filter等中处理。</li><li>前端在向后端传送json格式的数据时，习惯将contentType字段的值设置为application/json，导致请求变为复杂请求。</li><li>复杂请求每次在发送正式请求前都要发送预请求，不仅加重了网络负担，也使得客户端得到响应的速度下降，因此，前端应当尽可能避免发送复杂请求。</li></ol>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 后端 </tag>
            
            <tag> CORS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些安全常识</title>
      <link href="/2020/10/20/%E4%B8%80%E4%BA%9B%E5%AE%89%E5%85%A8%E5%B8%B8%E8%AF%86/"/>
      <url>/2020/10/20/%E4%B8%80%E4%BA%9B%E5%AE%89%E5%85%A8%E5%B8%B8%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="salt-盐值-的正确用法"><a href="#salt-盐值-的正确用法" class="headerlink" title="salt(盐值)的正确用法"></a>salt(盐值)的正确用法</h2><p>刚开始做web的时候，什么都不懂，只能照葫芦画瓢，跟着网上的博客做，在将用户密码存入数据库时，在用户密码的明文后加上一个固定的盐值，再通过加密算法把它们转换成密文存入数据库。这个学期学了网络安全之后，才发现盐值并不是这么用的。<br/></p><h3 id="什么是盐值？"><a href="#什么是盐值？" class="headerlink" title="什么是盐值？"></a>什么是盐值？</h3><p>通俗地说，盐值就是一个字符串，用来与需要加密的信息（如密码等）组成一个新的字符串，如盐值为“ztgs”，需要加密的信息为“123456”，那么新的字符串就是”123456ztgs”（当然也可以是“ztgs123456”等，具体组合规则可自行决定）。</p><h3 id="为什么需要使用盐值？"><a href="#为什么需要使用盐值？" class="headerlink" title="为什么需要使用盐值？"></a>为什么需要使用盐值？</h3><p>假设用户的密码是“123456”，且黑客（或者其他有恶意的人）知道我们使用的加密算法（一般我们使用的加密算法都是公开的，只是加密的次数不同），当数据库泄露时，即使用户密码以密文形式存储在数据库上，黑客无法直接知道用户密码，但黑客可以通过把一些常见的密码通过加密算法加密成密文，然后将密文与数据库上存储的密文相比较（即彩虹表攻击），若相同，则几乎就可以确定该用户的密码（不同明文加密出的密文可能相同，但概率极低）。但如果我们使用盐值，如盐值“ztgs”，那么我们需要加密的明文就是“123456ztgs”，存储在数据库中的时“123456ztgs”的密文，当密文一致时，对应的明文并不是用户真正的密码。但像这样使用固定盐值仍然存在隐患，即黑客如果知道盐值（黑客可能是内部人员），那么盐值就失去了作用。</p><h3 id="如何正确使用盐值？"><a href="#如何正确使用盐值？" class="headerlink" title="如何正确使用盐值？"></a>如何正确使用盐值？</h3><p>既然使用固定盐值不够安全，那就使用随机盐值咯。在用户注册时随机生成一个盐值，同时在数据库存储用户信息的表中开辟一个salt字段存储盐值，这样，即使数据库泄露，黑客同时知道用户密码的密文以及用于加密的盐值，破解用户密码的难度仍然大大提升。为什么呢？对于特定的一个用户而言，他的密码可能是常见密码表中的任何一个，因此，为了破解该用户的密码，需要给常见密码表中的每一个密码加上盐值，然后再加密成密文与数据库中存储的该用户的密码密文相比较，假设常见密码表长为100万（实际上远大于100万），数据库中有100万条用户数据，若盐值都不一样，那么黑客需要计算出100万*100万条密文，才能破解数据库中的存储的用户密码，而若使用固定盐值，则只需要计算出100万条密文。</p><h2 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h2>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
