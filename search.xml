<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>最佳归并树</title>
      <link href="/2021/02/12/%E6%9C%80%E4%BD%B3%E5%BD%92%E5%B9%B6%E6%A0%91/"/>
      <url>/2021/02/12/%E6%9C%80%E4%BD%B3%E5%BD%92%E5%B9%B6%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近碰到一道题：已知三叉树T中6个叶结点的权分别是2，3，4，5，6，7，求T的带权路径长度的最小值（某年计算机研究生考试真题）。<br><br>看到最短带权路径长度，第一反应是哈夫曼树，但题目中说了是三叉树，而哈夫曼树是二叉树，因此直接套用哈夫曼树显然是是不行的，但可以借鉴哈夫曼树的思想。<br></p><h2 id="哈夫曼树的构建"><a href="#哈夫曼树的构建" class="headerlink" title="哈夫曼树的构建"></a>哈夫曼树的构建</h2><ol><li>将n个结点看作n棵仅含一个结点的二叉树，构成森林F</li><li>构造一个新结点，从F中选取根结点权值最小的两棵二叉树A、B作为新结点的左、右子树形成一颗新的二叉树C，并将树C根结点的权值设为左、右子树根结点权值之和</li><li>从F中删除A、B，并将C加入F</li><li>重复步骤2、3直至F中只剩下一颗树</li></ol><p>可以看到，构建哈夫曼树最重要的思想，就是尽可能让权值大的结点靠近根结点，即先合并权值小的结点。<br></p><h2 id="最佳归并树的构建"><a href="#最佳归并树的构建" class="headerlink" title="最佳归并树的构建"></a>最佳归并树的构建</h2><p>先上一个结论：对于含m个叶结点的k叉树，若(m - 1) % (k - 1) = 0，则不需要添加虚结点，否则需要添加(k - 1) - (m - 1) % (k - 1)个虚结点。<br><br>所谓虚结点，就是权值比任何结点都小，但实际建树时不存在的结点。<br><br>于是k叉“哈夫曼树”的构建描述为：<br></p><ol><li>将m个结点看作m棵仅含一个结点的k叉树，构成森林F</li><li>构造一个新结点，从F中选取根结点权值最小的k棵k叉树（若有虚结点，则包含虚结点）作为新结点的子树形成一颗新的k叉树，并将根结点的权值设为所有子树根结点权值之和（求和时将虚结点的权值看作0）</li><li>从F中删除步骤2中选中的k棵k叉树，并将新的k叉树加入F</li><li>重复步骤2、3直至F中只剩下一颗K树</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> k叉树 </tag>
            
            <tag> 哈夫曼树 </tag>
            
            <tag> 最佳归并树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单请求和复杂请求</title>
      <link href="/2020/10/20/%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82%E5%92%8C%E5%A4%8D%E6%9D%82%E8%AF%B7%E6%B1%82/"/>
      <url>/2020/10/20/%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82%E5%92%8C%E5%A4%8D%E6%9D%82%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h2><p>同时满足以下两个条件的是简单请求：</p><ol><li>HTTP方法是head、get、post之一</li><li>HTTP头部信息不超出以下几种字段<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Accept</span><br><span class="line">Accept-Language</span><br><span class="line">Content-Language</span><br><span class="line">Last-Event-ID</span><br><span class="line">Content-Type </span><br></pre></td></tr></table></figure>且Content-Type仅能是下列之一<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">application/x-www-form-urlencoded</span><br><span class="line">multipart/form-data</span><br><span class="line">text/plain</span><br></pre></td></tr></table></figure><br/></li></ol><h2 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h2><p>不是简单请求的即为复杂请求<br/></p><h2 id="简单请求和复杂请求的区别"><a href="#简单请求和复杂请求的区别" class="headerlink" title="简单请求和复杂请求的区别"></a>简单请求和复杂请求的区别</h2><p>复杂请求在正式请求前会先发送一个预请求，预请求以options形式发送，在CORS（跨域资源共享）中，options头部会包含以下两个特有字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Request-Method – 该项内容是实际请求的类型，如get、post、put、delete等。</span><br><span class="line">Access-Control-Request-Headers – 该项是一个以逗号分隔的列表，当中是复杂请求所使用的头部。</span><br></pre></td></tr></table></figure><p>服务端需要对这两个字段进行回应，若服务端未进行回应，客户端将认为服务器不支持该跨域请求，于是不再发送正式请求。<br/><br>复杂请求的部分响应头及解释如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin（必含） – 允许跨域访问的源地址。</span><br><span class="line">Access-Control-Allow-Methods（必含） – 这是对预请求当中Access-Control-Request-Method的回复，这一回复将是一个以逗号分隔的列表。尽管客户端或许只请求某一方法，但服务端仍然可以返回所有允许的方法，以便客户端将其缓存。</span><br><span class="line">Access-Control-Allow-Headers（当预请求中包含Access-Control-Request-Headers时必须包含） – 这是对预请求当中Access-Control-Request-Headers的回复，和上面一样是以逗号分隔的列表，可以返回所有支持的头部。</span><br><span class="line">Access-Control-Allow-Credentials（可选） – 和简单请求当中作用相同。</span><br><span class="line">Access-Control-Max-Age（可选） – 以秒为单位的缓存时间。预请求的的发送并非免费午餐，允许时应当尽可能缓存。</span><br></pre></td></tr></table></figure><p>客户端收到响应后，根据Access-Control-Allow-Origin字段判断服务端是否允许自己跨域访问，根据Access-Control-Allow-Methods字段判断服务端是否允许自己以预请求中Access-Control-Request-Method字段中的请求类型访问，决定是否发送正式请求。<br/></p><h2 id="一些经验"><a href="#一些经验" class="headerlink" title="一些经验"></a>一些经验</h2><ol><li>options无法在Serve中被捕获到，因此不能在Serve中处理，需要在Serve之前的Filter等中处理。</li><li>前端在向后端传送json格式的数据时，习惯将contentType字段的值设置为application/json，导致请求变为复杂请求。</li><li>复杂请求每次在发送正式请求前都要发送预请求，不仅加重了网络负担，也使得客户端得到响应的速度下降，因此，前端应当尽可能避免发送复杂请求。</li></ol>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 后端 </tag>
            
            <tag> CORS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
